package main

import (
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	. "google.golang.org/protobuf/reflect/protoreflect"
)

// var bytes_type = "[..]u8"
var bytes_type = "string"

func getFieldKindName(field *protogen.Field) (string, error) {
	kind := field.Desc.Kind()
	switch kind {
	case Int32Kind, Sint32Kind, Sfixed32Kind:
		return "s32", nil
	case Uint32Kind, Fixed32Kind:
		return "u32", nil
	case Sint64Kind, Sfixed64Kind:
		return "s64", nil
	case Uint64Kind, Fixed64Kind:
		return "u64", nil
	case BoolKind:
		return "bool", nil
	case DoubleKind:
		return "float64", nil
	case FloatKind:
		return "float32", nil
	case EnumKind: 
		return string(field.Desc.Enum().Name()), nil
	case StringKind: 
		return "string", nil
	case MessageKind: 
		return string(field.Desc.Message().Name()), nil
	case BytesKind:
		return bytes_type, nil
	default:
		return "", fmt.Errorf("unmanaged field type in getFieldKindName %+v", kind)
	}
}

func getFieldDescriptor(field *protogen.Field) (string, error) {
	fk, _ := getFieldKindName(field)
	card := field.Desc.Cardinality()
	optional := "false";
	repeated := "false";
	if card == Optional {
		optional = "true";
	}
	if card == Repeated {
		repeated = "true";
	}
	switch field.Desc.Kind() {
	case Sfixed32Kind, Fixed32Kind, FloatKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.Fixed32}", field.Desc.Number(), fk, optional, repeated), nil
	case Sfixed64Kind, Fixed64Kind, DoubleKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.Fixed64}", field.Desc.Number(), fk, optional, repeated), nil
	case Int32Kind, Sint32Kind, Sint64Kind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.ZigZag}", field.Desc.Number(), fk, optional, repeated), nil
	case Uint32Kind, Uint64Kind, BoolKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.Varint}", field.Desc.Number(), fk, optional, repeated), nil
	case EnumKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.Varint}", field.Desc.Number(), fk, optional, repeated), nil
	case MessageKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.Size}", field.Desc.Number(), fk, optional, repeated), nil
	case StringKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(string), optional=%s, repeated=%s, wt=.Size}", field.Desc.Number(), optional, repeated), nil
	case BytesKind:
		return fmt.Sprintf("FieldDesc.{tag=%d, type=type_of(%s), optional=%s, repeated=%s, wt=.Size}", field.Desc.Number(), bytes_type, optional, repeated), nil

	default:
		return "", fmt.Errorf("unmanaged field type in  getFieldDescriptor %s", field.Desc.Kind())
	}
}

func generateFieldDescriptor(field *protogen.Field, g *protogen.GeneratedFile) error {
	if fieldDesc, err := getFieldDescriptor(field); err != nil {
		return err
	} else {
		g.P("        ", mangleName(string(field.Desc.Name())), " := ", fieldDesc, ";")
	}
	return nil
}

func mangleName(name string) string {
	if name == "context" {
		return "__name__context";
	}
	return name
}

func generateFieldDef(field *protogen.Field, g *protogen.GeneratedFile) error {
	if fieldKindName, err := getFieldKindName(field); err != nil {
		return err
	} else {
		card := field.Desc.Cardinality()
		prefix := "";
		if card == Optional {
			prefix = "*";
		}
		if card == Repeated {
			prefix = "[..]";
		}
		g.P("    ", mangleName(string(field.Desc.Name())), ": ", prefix, fieldKindName, ";")
	}
	return nil
}

func generateFile(p *protogen.Plugin, f *protogen.File) error {
	// Skip generating file if there is no message.
	filename := f.GeneratedFilenamePrefix + ".pb.jai"
	g := p.NewGeneratedFile(filename, "")
	g.P("// Code generated by protoc-gen-jai")
	g.P()
	g.P("#import \"proto\";")
	g.P("#import \"Basic\";")
	g.P("#import \"Deep_Copy\";")
	// g.P("const std = @import(\"std\");")
	// g.P("const mem = std.mem;")
	// g.P("const Allocator = mem.Allocator;")
	// g.P("const ArrayList = std.ArrayList;")
	// g.P()
	// g.P("const protobuf = @import(\"protobuf\");")
	// g.P("const FieldDescriptor = protobuf.FieldDescriptor;")
	// g.P("const pb_decode = protobuf.pb_decode;")
	// g.P("const pb_encode = protobuf.pb_encode;")
	// g.P("const pb_deinit = protobuf.pb_deinit;")
	// g.P("const pb_init = protobuf.pb_init;")
	// g.P("const fd = protobuf.fd;")
	g.P()
	for _, m := range f.Enums {
		g.P()
		msgName := m.Desc.Name()
		g.P(msgName, " :: enum s32 {")
		// field definitions
		for _, val := range m.Values {
			g.P("    ", val.Desc.Name(), " :: ", val.Desc.Number(), ";")
		}
		g.P("};")
	}

	for _, m := range f.Messages {
		msgName := m.Desc.Name()

		g.P(msgName, " :: struct {")

		// field definitions
		for _, field := range m.Fields {
			if err := generateFieldDef(field, g); err != nil {
				return err
			}
		}
		g.P()

		// field descriptors
		g.P("    _desc_table :: struct {")
		for _, field := range m.Fields {
			if err := generateFieldDescriptor(field, g); err != nil {
				return err
			}
		}
		g.P("    };")
		g.P()

		g.P("    encode :: (b: *[..]u8, self: ", msgName, ") {")
		g.P("        #insert #run encode_code_writer(", msgName, ".{});")
		g.P("    }")
		g.P()

		g.P("    decode :: (b: []u8) -> ", msgName, " {")
		g.P("        #insert #run decode_code_writer(", msgName, ".{});")
		g.P("    }")
		g.P()


		// for _, field := range m.Fields {
		// 	if field.Desc.Cardinality() == Optional {
		// 		kn, _ := getFieldKindName(field);
		// 		g.P("    set_", mangleName(string(field.Desc.Name())) , " :: (val: *",msgName, ", in: ", kn ,") {")
		// 		g.P("        val.", mangleName(string(field.Desc.Name())) , " = Deep_Copy(*in, Deep_Copy_Config.{});");
		// 		g.P("    }")
		// 		g.P()
		// 	}
		// }

		// g.P("    init :: () -> ", msgName, " {")
		// g.P("        //return pb_init(", msgName, ");")
		// g.P("    }")
		// g.P()
		//
		// g.P("    deinit :: (self: ", msgName, ") {")
		// g.P("        //return pb_deinit(self);")
		// g.P("    }")

		g.P("};")
		g.P("#insert #run setters_code_writer(", msgName, ".{});")
	}

	return nil
}

func main() {
	protogen.Options{}.Run(func(plugin *protogen.Plugin) error {
		for _, file := range plugin.Files {
			if !file.Generate {
				continue
			}

			if err := generateFile(plugin, file); err != nil {
				return err
			}
		}

		return nil
	})
}
